{\rtf1\ansi\ansicpg1250\uc1 \deff0\deflang1029\deflangfe1029{\fonttbl{\f0\froman\fcharset238\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f2\fmodern\fcharset238\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f60\froman\fcharset0\fprq2 Times New Roman;}{\f59\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f61\froman\fcharset161\fprq2 Times New Roman Greek;}{\f62\froman\fcharset162\fprq2 Times New Roman Tur;}
{\f63\froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\f64\froman\fcharset178\fprq2 Times New Roman (Arabic);}{\f65\froman\fcharset186\fprq2 Times New Roman Baltic;}{\f76\fmodern\fcharset0\fprq1 Courier New;}
{\f75\fmodern\fcharset204\fprq1 Courier New Cyr;}{\f77\fmodern\fcharset161\fprq1 Courier New Greek;}{\f78\fmodern\fcharset162\fprq1 Courier New Tur;}{\f79\fmodern\fcharset177\fprq1 Courier New (Hebrew);}
{\f80\fmodern\fcharset178\fprq1 Courier New (Arabic);}{\f81\fmodern\fcharset186\fprq1 Courier New Baltic;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;
\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{
\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1029\langfe1029\cgrid\langnp1029\langfenp1029 \snext0 Normal;}{\*\cs10 \additive Default Paragraph Font;}}{\info{\author zdenek}{\operator zdenek}
{\creatim\yr2004\mo3\dy10\hr15\min32}{\revtim\yr2004\mo3\dy10\hr15\min35}{\version2}{\edmins3}{\nofpages2}{\nofwords436}{\nofchars2487}{\*\company ZJ}{\nofcharsws3054}{\vern8269}}\paperw11907\paperh16840\margl1701\margr1134\margt1418\margb1134 
\widowctrl\ftnbj\aenddoc\hyphhotz425\noxlattoyen\expshrtn\noultrlspc\dntblnsbdb\nospaceforul\hyphcaps0\horzdoc\dghspace120\dgvspace120\dghorigin1701\dgvorigin1984\dghshow0\dgvshow3\jcompress\viewkind4\viewscale150\nolnhtadjtbl \fet0\sectd 
\psz9\linex0\headery709\footery709\colsx708\sectdefaultcl {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4
\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}
{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 
\fs24\lang1029\langfe1029\cgrid\langnp1029\langfenp1029 {\f2\fs18\cf1 
\par }{\b\f2\fs18\cf1 xmlDocPtr\tab xmlNewDoc( const xmlChar * version )}{\f2\fs18\cf1 
\par 
\par Creates a new XML document
\par version: xmlChar string giving the version of XML "1.0" 
\par Returns: a new document
\par 
\par 
\par }{\b\f2\fs18\cf1 xmlNodePtr\tab xmlNewDocNode( xmlDocPtr       doc,
\par                              xmlNsPtr        ns,
\par                              const xmlChar * name,
\par                              const xmlChar * content}{\b\f2\fs18\cf1\lang1033\langfe1029\langnp1033  }{\b\f2\fs18\cf1 )}{\f2\fs18\cf1 
\par 
\par Creation of a new node element within a document. @ns and @content are optional (NULL). NOTE: @content is supposed to be a piece of XML CDATA, so it 
allow entities references, but XML special chars need to be escaped first by using xmlEncodeEntitiesReentrant(). Use xmlNewDocRawNode() if you don't need entities support.
\par 
\par doc: the document 
\par ns: namespace if any 
\par name: the node name 
\par content: the XML text content if any 
\par Returns: a pointer to the new node object. 
\par 
\par 
\par 
\par }{\b\f2\fs18\cf1 xmlNodePtr\tab xmlNewChild( xmlNodePtr      parent,
\par                           xmlNsPtr        ns,
\par                           const xmlChar * name,
\par                           const xmlChar * content)}{\f2\fs18\cf1 
\par 
\par Creation of a new child element, added at the end of @parent children list. @ns and @content parameters are optional (NULL). If @ns is NULL, the newly created element inherits the namespace of @parent. If @content is non NULL, a child list containing th
e TEXTs and ENTITY_REFs node will be created. NOTE: @content is supposed to be a piece of XML CDATA, so it allows entity references. XML special chars must be escaped first by using xmlEncodeEntitiesReentrant(), or xmlNewTextChild() should be used.
\par 
\par parent: the parent node 
\par ns: a namespace if any 
\par name: the name of the child 
\par content: the XML content of the child if any. 
\par Returns: a pointer to the new node object.
\par 
\par 
\par }{\b\f2\fs18\cf1 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par xmlDocPtr\tab xmlCopyDoc( xmlDocPtr doc, int recursive)}{\f2\fs18\cf1 
\par 
\par Do a copy of the document info. If recursive, the content tree will be copied too as well as DTD, namespaces and entities.
\par 
\par doc: the document 
\par recursive: if 1 do a recursive copy. 
\par Returns: a new #xmlDocPtr, or NULL in case of error.
\par 
\par 
\par }{\b\f2\fs18\cf1 xmlNodePtr\tab xmlCopyNode( const xmlNodePtr node, int recursive)
\par }{\f2\fs18\cf1 
\par Do a copy of the node.
\par 
\par node: the node 
\par recursive: if 1 do a recursive copy. 
\par Returns: a new #xmlNodePtr, or NULL in case of error.
\par 
\par 
\par }{\b\f2\fs18\cf1 int\tab xmlDocDump( FILE * f, xmlDocPtr cur )
\par }{\f2\fs18\cf1 
\par Dump an XML document to an open FILE.
\par 
\par f: the FILE* 
\par cur: the document 
\par Returns: the number of bytes written or -1 in case of failure.
\par 
\par 
\par }{\b\f2\fs18\cf1 void\tab xmlElemDump( FILE * f, xmlDocPtr doc, xmlNodePtr cur)
\par }{\f2\fs18\cf1 
\par Dump an XML/HTML node, recursive behaviour, children are printed too.
\par 
\par f: the FILE * for the output 
\par doc: the document 
\par cur: the current node
\par 
\par 
\par }{\b\f2\fs18\cf1 xmlNodePtr\tab xmlAddChild( xmlNodePtr parent, xmlNodePtr cur)
\par }{\f2\fs18\cf1 
\par Add a new node to @parent, at the end of the child (or property) list merging adjacent TEXT nodes (in which case @cur is freed) If the new node is ATTRIBUTE, it is 
added into properties instead of children. If there is an attribute with equal name, it is first destroyed.
\par 
\par parent: the parent node 
\par cur: the child node 
\par Returns: the child or NULL in case of error.
\par }}