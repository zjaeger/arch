{\rtf1\ansi\ansicpg1250\uc1 \deff0\deflang1029\deflangfe1029{\fonttbl{\f0\froman\fcharset238\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fswiss\fcharset238\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset238\fprq1{\*\panose 02070309020205020404}Courier New;}{\f61\froman\fcharset0\fprq2 Times New Roman;}{\f60\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f62\froman\fcharset161\fprq2 Times New Roman Greek;}
{\f63\froman\fcharset162\fprq2 Times New Roman Tur;}{\f64\froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\f65\froman\fcharset178\fprq2 Times New Roman (Arabic);}{\f66\froman\fcharset186\fprq2 Times New Roman Baltic;}
{\f69\fswiss\fcharset0\fprq2 Arial;}{\f68\fswiss\fcharset204\fprq2 Arial Cyr;}{\f70\fswiss\fcharset161\fprq2 Arial Greek;}{\f71\fswiss\fcharset162\fprq2 Arial Tur;}{\f72\fswiss\fcharset177\fprq2 Arial (Hebrew);}
{\f73\fswiss\fcharset178\fprq2 Arial (Arabic);}{\f74\fswiss\fcharset186\fprq2 Arial Baltic;}{\f77\fmodern\fcharset0\fprq1 Courier New;}{\f76\fmodern\fcharset204\fprq1 Courier New Cyr;}{\f78\fmodern\fcharset161\fprq1 Courier New Greek;}
{\f79\fmodern\fcharset162\fprq1 Courier New Tur;}{\f80\fmodern\fcharset177\fprq1 Courier New (Hebrew);}{\f81\fmodern\fcharset178\fprq1 Courier New (Arabic);}{\f82\fmodern\fcharset186\fprq1 Courier New Baltic;}}{\colortbl;\red0\green0\blue0;
\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;
\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1029\langfe1029\cgrid\langnp1029\langfenp1029 \snext0 Normal;}
{\*\cs10 \additive Default Paragraph Font;}{\s15\ql \li0\ri0\widctlpar\tqc\tx4536\tqr\tx9072\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1029\langfe1029\cgrid\langnp1029\langfenp1029 \sbasedon0 \snext15 header;}{\*\cs16 \additive 
\sbasedon10 page number;}{\s17\ql \li0\ri0\widctlpar\tqc\tx4536\tqr\tx9072\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1029\langfe1029\cgrid\langnp1029\langfenp1029 \sbasedon0 \snext17 footer;}}{\info{\author zdenek}{\operator zdenek}
{\creatim\yr2004\mo3\dy9\hr17\min31}{\revtim\yr2004\mo3\dy9\hr17\min43}{\printim\yr2004\mo3\dy9\hr17\min43}{\version4}{\edmins12}{\nofpages5}{\nofwords1662}{\nofchars9475}{\*\company ZJ}{\nofcharsws11635}{\vern8269}}
\paperw11907\paperh16840\margl1701\margr1134\margt1418\margb1134 \widowctrl\ftnbj\aenddoc\hyphhotz425\noxlattoyen\expshrtn\noultrlspc\dntblnsbdb\nospaceforul\hyphcaps0\horzdoc\dghspace120\dgvspace120\dghorigin1701\dgvorigin1984\dghshow0\dgvshow3
\jcompress\viewkind1\viewscale100\nolnhtadjtbl \fet0\sectd \psz9\linex0\headery709\footery709\colsx708\sectdefaultcl {\header \pard\plain \s15\ql \li0\ri0\widctlpar
\tqc\tx4536\tqr\tx9072\pvpara\phmrg\posxc\posy0\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1029\langfe1029\cgrid\langnp1029\langfenp1029 {\field{\*\fldinst {\cs16\fs18 PAGE  }}{\fldrslt {\cs16\fs18\lang1024\langfe1024\noproof 1}}}{
\cs16\fs18 
\par }\pard \s15\ql \li0\ri0\widctlpar\tqc\tx4536\tqr\tx9072\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\field{\*\fldinst {\fs18  FILENAME }}{\fldrslt {\fs18\lang1024\langfe1024\noproof xml_parser_iface.rtf}}}{\fs18 
\par }}{\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}
{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8
\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \ql \li0\ri0\sb100\sa100\nowidctlpar\faauto\rin0\lin0\itap0 
\fs24\lang1029\langfe1029\cgrid\langnp1029\langfenp1029 {\fs20 
This section is directly intended to help programmers getting bootstrapped using the XML tollkit from the C language. It is not intended to be extensive. I hope the automatically generated documents will provide the completeness required, but as a separat
e set of documents. The interfaces of the XML parser are by principle low level, Those interested in a higher level API should }{\fs20\ul\cf2 look at DOM}{\fs20 .}{\fs20\lang1033\langfe1029\langnp1033 
\par The}{\fs20  }{\fs20\ul\cf2 parser interfaces for XML <html/libxml-parser.html>}{\fs20  are separated from the }{\fs20\ul\cf2 HTML parser interfaces <html/libxml-htmlparser.html>}{\fs20 . Let's have a look at how the XML parser can be called:
\par }\pard \ql \li0\ri0\sb100\sa100\keepn\nowidctlpar\faauto\rin0\lin0\itap0 {\b\fs20 Invoking the parser : the pull method
\par }\pard \ql \li0\ri0\sb100\sa100\nowidctlpar\faauto\rin0\lin0\itap0 {\fs20 Usually, the first thing to do is to read an XML input. The parser accepts documents either from in-memory strings or from files. The functions are defined in "parser.h":
\par }{\f2\fs20 xmlDocPtr xmlParseMemory(char *buffer, int size);}{\fs20  
\par }\pard \ql \li360\ri0\sb100\sa100\nowidctlpar\faauto\rin0\lin360\itap0 {\fs20 Parse a null-terminated string containing the document.
\par }\pard \ql \li0\ri0\sb100\sa100\nowidctlpar\faauto\rin0\lin0\itap0 {\f2\fs20 xmlDocPtr xmlParseFile(const char *filename);}{\fs20  
\par }\pard \ql \li360\ri0\sb100\sa100\nowidctlpar\faauto\rin0\lin360\itap0 {\fs20 Parse an XML document contained in a (possibly compressed) file.
\par }\pard \ql \li0\ri0\sb100\sa100\nowidctlpar\faauto\rin0\lin0\itap0 {\fs20 The parser returns a pointer to the document structure (or NULL in case of failure).
\par }\pard \ql \li0\ri0\sb100\sa100\keepn\nowidctlpar\faauto\rin0\lin0\itap0 {\b\fs20 Invoking the parser: the push method
\par }\pard \ql \li0\ri0\sb100\sa100\nowidctlpar\faauto\rin0\lin0\itap0 {\fs20 In order for the application to keep the control when the document is being fetched (which is common for GUI based programs) libxml2 provides a pus
h interface, too, as of version 1.8.3. Here are the interface functions:
\par }\pard \ql \li0\ri0\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631\faauto\rin0\lin0\itap0 {\f2\fs20 xmlParserCtxtPtr xmlCreatePushParserCtxt(xmlSAXHandlerPtr sax,
\par                                          void *user_data,
\par                                          const char *chunk,
\par                                          int size,
\par                                          const char *filename);
\par int              xmlParseChunk          (xmlParserCtxtPtr ctxt,
\par                                          const char *chunk,
\par                                          int size,
\par                                          int terminate);
\par }\pard \ql \li0\ri0\sb100\sa100\nowidctlpar\faauto\rin0\lin0\itap0 {\fs20 and here is a simple example showing how to use the interface:
\par }\pard \ql \li0\ri0\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631\faauto\rin0\lin0\itap0 {\f2\fs20             FILE *f;
\par 
\par             f = fopen(filename, "r");
\par             if (f != NULL) \{
\par                 int res, size = 1024;
\par                 char chars[1024];
\par                 xmlParserCtxtPtr ctxt;
\par 
\par                 res = fread(chars, 1, 4, f);
\par                 if (res > 0) \{
\par                     ctxt = xmlCreatePushParserCtxt(NULL, NULL,
\par                                 chars, res, filename);
\par                     while ((res = fread(chars, 1, size, f)) > 0) \{
\par                         xmlParseChunk(ctxt, chars, res, 0);
\par                     \}
\par                     xmlParseChunk(ctxt, chars, 0, 1);
\par                     doc = ctxt->myDoc;
\par                     xmlFreeParserCtxt(ctxt);
\par                 \}
\par             \}
\par }\pard \ql \li0\ri0\sb100\sa100\nowidctlpar\faauto\rin0\lin0\itap0 {\fs20 The HTML parser embedded into libxml2 also has a push interface; the functions are just prefixed by "html" rather than "xml".
\par }\pard \ql \li0\ri0\sb100\sa100\keepn\nowidctlpar\faauto\rin0\lin0\itap0 {\b\fs20 Invoking the parser: the SAX interface
\par }\pard \ql \li0\ri0\sb100\sa100\nowidctlpar\faauto\rin0\lin0\itap0 {\fs20 
The tree-building interface makes the parser memory-hungry, first loading the document in memory and then building the tree itself. Reading a document without building the tree is possible using the SAX interfaces (see SAX.h and }{\fs20\ul\cf2 
James Henstridge's documentation <http://www.daa.com.au/~james/gnome/xml-sax/xml-sax.html>}{\fs20 ). Note also that the push interface can be limited to SAX: just use the two first arguments of }{\f2\fs20 xmlCreatePushParserCtxt()}{\fs20 .
\par }\pard \ql \li0\ri0\sb100\sa100\keepn\nowidctlpar\faauto\rin0\lin0\itap0 {\b\fs20 Building a tree from scratch
\par }\pard \ql \li0\ri0\sb100\sa100\nowidctlpar\faauto\rin0\lin0\itap0 {\fs20 The other way to get an XML tree i
n memory is by building it. Basically there is a set of functions dedicated to building new elements. (These are also described in <libxml/tree.h>.) For example, here is a piece of code that produces the XML document used in the previous examples:
\par }\pard \ql \li0\ri0\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631\faauto\rin0\lin0\itap0 {\f2\fs20     #include <libxml/tree.h>
\par     xmlDocPtr doc;
\par     xmlNodePtr tree, subtree;
\par 
\par     doc = xmlNewDoc("1.0");
\par     doc->children = xmlNewDocNode(doc, NULL, "EXAMPLE", NULL);
\par     xmlSetProp(doc->children, "prop1", "gnome is great");
\par     xmlSetProp(doc->children, "prop2", "& linux too");
\par     tree = xmlNewChild(doc->children, NULL, "head", NULL);
\par     subtree = xmlNewChild(tree, NULL, "title", "Welcome to Gnome");
\par     tree = xmlNewChild(doc->children, NULL, "chapter", NULL);
\par     subtree = xmlNewChild(tree, NULL, "title", "The Linux adventure");
\par     subtree = xmlNewChild(tree, NULL, "p", "bla bla bla ...");
\par     subtree = xmlNewChild(tree, NULL, "image", NULL);
\par     xmlSetProp(subtree, "href", "linus.gif");
\par }\pard \ql \li0\ri0\sb100\sa100\nowidctlpar\faauto\rin0\lin0\itap0 {\fs20 Not really rocket science ...
\par }\pard \ql \li0\ri0\sb100\sa100\keepn\nowidctlpar\faauto\rin0\lin0\itap0 {\b\fs20 Traversing the tree
\par }\pard \ql \li0\ri0\sb100\sa100\nowidctlpar\faauto\rin0\lin0\itap0 {\fs20 Basically by }{\fs20\ul\cf2 including "tree.h" <html/libxml-tree.html>}{\fs20 
 your code has access to the internal structure of all the elements of the tree. The names should be somewhat simple like }{\b\fs20 parent}{\fs20 , }{\b\fs20 children}{\fs20 , }{\b\fs20 next}{\fs20 , }{\b\fs20 prev}{\fs20 , }{\b\fs20 properties}{\fs20 
, etc... For example, still with the previous example:
\par }\pard \ql \li0\ri0\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631\faauto\rin0\lin0\itap0 {\f2\fs20 doc->children->children->children
\par }\pard \ql \li0\ri0\sb100\sa100\nowidctlpar\faauto\rin0\lin0\itap0 {\fs20 points to the title element,
\par }\pard \ql \li0\ri0\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631\faauto\rin0\lin0\itap0 {\f2\fs20 doc->children->children->next->children->children
\par }\pard \ql \li0\ri0\sb100\sa100\nowidctlpar\faauto\rin0\lin0\itap0 {\fs20 points to the text node containing the chapter title "The Linux adventure".
\par }{\b\fs20 NOTE}{\fs20 : XML allows }{\i\fs20 PI}{\fs20 s and }{\i\fs20 comments}{\fs20  to be present before the document root, so }{\f2\fs20 doc->children}{\fs20  may point to an element which is not the document Root Element; a function }{\f2\fs20 
xmlDocGetRootElement()}{\fs20  was added for this purpose.
\par }\pard \ql \li0\ri0\sb100\sa100\keepn\nowidctlpar\faauto\rin0\lin0\itap0 {\b\fs20 Modifying the tree
\par }\pard \ql \li0\ri0\sb100\sa100\nowidctlpar\faauto\rin0\lin0\itap0 {\fs20 Functions are provided for reading and writing the document content. Here is an excerpt from the }{\fs20\ul\cf2 tree API <html/libxml-tree.html>}{\fs20 :
\par }{\f2\fs20 xmlAttrPtr xmlSetProp(xmlNodePtr node, const xmlChar *name, const xmlChar *value);}{\fs20  
\par }\pard \ql \li360\ri0\sb100\sa100\nowidctlpar\faauto\rin0\lin360\itap0 {\fs20 This sets (or changes) an attribute carried by an ELEMENT node. The value can be NULL.
\par }\pard \ql \li0\ri0\sb100\sa100\nowidctlpar\faauto\rin0\lin0\itap0 {\f2\fs20 const xmlChar *xmlGetProp(xmlNodePtr node, const xmlChar *name);}{\fs20  
\par }\pard \ql \li360\ri0\sb100\sa100\nowidctlpar\faauto\rin0\lin360\itap0 {\fs20 This function returns a pointer to new copy of the property content. Note that the user must deallocate the result.
\par }\pard \ql \li0\ri0\sb100\sa100\nowidctlpar\faauto\rin0\lin0\itap0 {\fs20 Two functions are provided for reading and writing the text associated with elements:
\par }{\f2\fs20 xmlNodePtr xmlStringGetNodeList(xmlDocPtr doc, const xmlChar *value);}{\fs20  
\par }\pard \ql \li360\ri0\sb100\sa100\nowidctlpar\faauto\rin0\lin360\itap0 {\fs20 
This function takes an "external" string and converts it to one text node or possibly to a list of entity and text nodes. All non-predefined entity references like &Gnome; will be stored internally as entity nodes, hen
ce the result of the function may not be a single node.
\par }\pard \ql \li0\ri0\sb100\sa100\nowidctlpar\faauto\rin0\lin0\itap0 {\f2\fs20 xmlChar *xmlNodeListGetString(xmlDocPtr doc, xmlNodePtr list, int inLine);}{\fs20  
\par }\pard \ql \li360\ri0\sb100\sa100\nowidctlpar\faauto\rin0\lin360\itap0 {\fs20 This function is the inverse of }{\f2\fs20 xmlStringGetNodeList()}{\fs20 . It generates a new string containing the content of the text and ent
ity nodes. Note the extra argument inLine. If this argument is set to 1, the function will expand entity references. For example, instead of returning the &Gnome; XML encoding in the string, it will substitute it with its value (say, "GNU Network Object M
odel Environment").
\par }\pard \ql \li0\ri0\sb100\sa100\keepn\nowidctlpar\faauto\rin0\lin0\itap0 {\b\fs20 Saving a tree
\par }\pard \ql \li0\ri0\sb100\sa100\nowidctlpar\faauto\rin0\lin0\itap0 {\fs20 Basically 3 options are possible:
\par }{\f2\fs20 void xmlDocDumpMemory(xmlDocPtr cur, xmlChar**mem, int *size);}{\fs20  
\par }\pard \ql \li360\ri0\sb100\sa100\nowidctlpar\faauto\rin0\lin360\itap0 {\fs20 Returns a buffer into which the document has been saved.
\par }\pard \ql \li0\ri0\sb100\sa100\nowidctlpar\faauto\rin0\lin0\itap0 {\f2\fs20 extern void xmlDocDump(FILE *f, xmlDocPtr doc);}{\fs20  
\par }\pard \ql \li360\ri0\sb100\sa100\nowidctlpar\faauto\rin0\lin360\itap0 {\fs20 Dumps a document to an open file descriptor.
\par }\pard \ql \li0\ri0\sb100\sa100\nowidctlpar\faauto\rin0\lin0\itap0 {\f2\fs20 int xmlSaveFile(const char *filename, xmlDocPtr cur);}{\fs20  
\par }\pard \ql \li360\ri0\sb100\sa100\nowidctlpar\faauto\rin0\lin360\itap0 {\fs20 Saves the document to a file. In this case, the compression interface is triggered if it has been turned on.
\par }\pard \ql \li0\ri0\sb100\sa100\keepn\nowidctlpar\faauto\rin0\lin0\itap0 {\b\fs20 Compression
\par }\pard \ql \li0\ri0\sb100\sa100\nowidctlpar\faauto\rin0\lin0\itap0 {\fs20 The library transparently handles compression when doing file-based accesses. The level of compression on saves can be turned on either globally or individually for one file:
\par }{\f2\fs20 int xmlGetDocCompressMode (xmlDocPtr doc);}{\fs20  
\par }\pard \ql \li360\ri0\sb100\sa100\nowidctlpar\faauto\rin0\lin360\itap0 {\fs20 Gets the document compression ratio (0-9).
\par }\pard \ql \li0\ri0\sb100\sa100\nowidctlpar\faauto\rin0\lin0\itap0 {\f2\fs20 void xmlSetDocCompressMode (xmlDocPtr doc, int mode);}{\fs20  
\par }\pard \ql \li360\ri0\sb100\sa100\nowidctlpar\faauto\rin0\lin360\itap0 {\fs20 Sets the document compression ratio.
\par }\pard \ql \li0\ri0\sb100\sa100\nowidctlpar\faauto\rin0\lin0\itap0 {\f2\fs20 int xmlGetCompressMode(void);}{\fs20  
\par }\pard \ql \li360\ri0\sb100\sa100\nowidctlpar\faauto\rin0\lin360\itap0 {\fs20 Gets the default compression ratio.
\par }\pard \ql \li0\ri0\sb100\sa100\nowidctlpar\faauto\rin0\lin0\itap0 {\f2\fs20 void xmlSetCompressMode(int mode);}{\fs20  
\par }\pard \ql \li360\ri0\sb100\sa100\nowidctlpar\faauto\rin0\lin360\itap0 {\fs20 Sets the default compression ratio.
\par }\pard \ql \li0\ri0\sb100\sa100\nowidctlpar\faauto\rin0\lin0\itap0 {\fs20\ul\cf2 Daniel Veillard <bugs.html>}{\fs20 
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 {\f1\fs20 
\par 
\par }\pard \ql \li0\ri0\pagebb\nowidctlpar\faauto\rin0\lin0\itap0 {\f1\fs20 tree
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 {\f1\fs20 
\par }{\f2\fs20 typedef enum \{
\par     XML_ELEMENT_NODE=\tab \tab 1,
\par     XML_ATTRIBUTE_NODE=\tab \tab 2,
\par     XML_TEXT_NODE=\tab \tab 3,
\par     XML_CDATA_SECTION_NODE=\tab 4,
\par     XML_ENTITY_REF_NODE=\tab 5,
\par     XML_ENTITY_NODE=\tab \tab 6,
\par     XML_PI_NODE=\tab \tab \tab 7,
\par     XML_COMMENT_NODE=\tab \tab 8,
\par     XML_DOCUMENT_NODE=\tab \tab 9,
\par     XML_DOCUMENT_TYPE_NODE=\tab 10,
\par     XML_DOCUMENT_FRAG_NODE=\tab 11,
\par     XML_NOTATION_NODE=\tab \tab 13,
\par     XML_HTML_DOCUMENT_NODE=\tab 13,
\par     XML_DTD_NODE=\tab \tab \tab 14,
\par     XML_ELEMENT_DECL=\tab \tab 15,
\par     XML_ATTRIBUTE_DECL=\tab \tab 16,
\par     XML_ENTITY_DECL=\tab \tab 17,
\par     XML_NAMESPACE_DECL=\tab \tab 18,
\par     XML_XINCLUDE_START=\tab \tab 19,
\par     XML_XINCLUDE_END=\tab \tab 20
\par #ifdef LIBXML_DOCB_ENABLED
\par    ,XML_DOCB_DOCUMENT_NODE=\tab 21
\par #endif
\par \} xmlElementType ;
\par 
\par 
\par typedef struct _xmlNode xmlNode;
\par typedef xmlNode *xmlNodePtr;
\par struct _xmlNode \{
\par     void           *_private;\tab /* application data */
\par     xmlElementType   type;\tab /* type number, must be second ! */
\par     const xmlChar   *name;\tab /* the name of the node, or the entity */
\par     struct _xmlNode *children;/* parent->childs link */
\par     struct _xmlNode *last;\tab /* last child link */
\par     struct _xmlNode *parent;\tab /* child->parent link */
\par     struct _xmlNode *next;\tab /* next sibling link  */
\par     struct _xmlNode *prev;\tab /* previous sibling link  */
\par     struct _xmlDoc  *doc;\tab /* the containing document */
\par 
\par     /* End of common part */
\par     xmlNs           *ns;        /* pointer to the associated namespace */
\par     xmlChar         *content;   /* the content */
\par     struct _xmlAttr *properties;/* properties list */
\par     xmlNs           *nsDef;     /* namespace definitions on this node */
\par     void            *psvi;\tab /* for type/PSVI informations */
\par     unsigned short   line;\tab /* line number */
\par     unsigned short   extra;\tab /* extra data for XPath/XSLT */
\par \};
\par 
\par 
\par typedef struct _xmlAttr xmlAttr;
\par typedef xmlAttr *xmlAttrPtr;
\par struct _xmlAttr \{
\par     void           *_private;\tab /* application data */
\par     xmlElementType   type;      /* XML_ATTRIBUTE_NODE, must be second ! */
\par     const xmlChar   *name;      /* the name of the property */
\par     struct _xmlNode *children;\tab /* the value of the property */
\par     struct _xmlNode *last;\tab /* NULL */
\par     struct _xmlNode *parent;\tab /* child->parent link */
\par     struct _xmlAttr *next;\tab /* next sibling link  */
\par     struct _xmlAttr *prev;\tab /* previous sibling link  */
\par     struct _xmlDoc  *doc;\tab /* the containing document */
\par     xmlNs           *ns;        /* pointer to the associated namespace */
\par     xmlAttributeType atype;     /* the attribute type if validating */
\par     void            *psvi;\tab /* for type/PSVI informations */
\par \};
\par /**
\par  * xmlNodeListGetRawString:
\par  * @doc:  the document
\par  * @list:  a Node list
\par  * @inLine:  should we replace entity contents or show their external form
\par  *
\par  * Builds the string equivalent to the text contained in the Node list
\par  * made of TEXTs and ENTITY_REFs, contrary to xmlNodeListGetString()
\par  * this function doesn't do any character encoding handling.
\par  *
\par  * Returns a pointer to the string copy, the caller must free it with xmlFree().
\par  */
\par xmlChar *
\par xmlNodeListGetRawString(xmlDocPtr doc, xmlNodePtr list, int inLine) ;
\par 
\par 
\par /**
\par  * xmlNodeListGetString:
\par  * @doc:  the document
\par  * @list:  a Node list
\par  * @inLine:  should we replace entity contents or show their external form
\par  *
\par  * Build the string equivalent to the text contained in the Node list
\par  * made of TEXTs and ENTITY_REFs
\par  *
\par  * Returns a pointer to the string copy, the caller must free it with xmlFree().
\par  */
\par xmlChar *
\par xmlNodeListGetString(xmlDocPtr doc, xmlNodePtr list, int inLine) ;
\par 
\par 
\par /**
\par  * xmlGetProp:
\par  * @node:  the node
\par  * @name:  the attribute name
\par  *
\par  * Search and get the value of an attribute associated to a node
\par  * This does the entity substitution.
\par  * This function looks in DTD attribute declaration for #FIXED or
\par  * default declaration values unless DTD use has been turned off.
\par  * NOTE: this function acts independently of namespaces associated
\par  *       to the attribute. Use xmlGetNsProp() or xmlGetNoNsProp()
\par  *       for namespace aware processing.
\par  *
\par  * Returns the attribute value or NULL if not found.
\par  *     It's up to the caller to free the memory with xmlFree().
\par  */
\par xmlChar *
\par xmlGetProp(xmlNodePtr node, const xmlChar *name) ;
\par }}